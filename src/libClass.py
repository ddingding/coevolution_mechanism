"""
library classes:
Classes and functions to process and hold the sequencing data, incl. single and multi-mutant data. 

Hierarchical outline:

Timecourse object: corresponds to a time course experiment with samples taken at multiple timepoints
        |
        Sample Object: corresponds to a single sample for which high-throughput sequencing has been performed
            |
            Mutant Object: corresponds to an individual mutant read
                |
                Single Codon mutant object: single codon mutant

"""
import numpy as np
import csv
from collections import defaultdict, Counter
from copy import deepcopy
from constants import WT_PARE_DNA, WT_PARD_DNA, CODON_TABLE

from mutTools import (
    translate,
    mutdic_to_mutcodon
)

class SingleCodonMutant:
    """
    single codon mutant object to store different attributes, such as
    template    :   'pare' vs. 'pard'
    mut_str     :   mut string code indicating the mutations to the DNA sequence, ie. '30:T,31:T'
    AA_pos      :   amino acid position of the single codon mutant
    codon_pos   :   position in the codon
    wt_codon    :   the wild type codon
    mut_codon   :   mutant codon
    wt_aa       :   wt amino acid
    mut_aa      :   mutant amino acid.
    """

    def __init__(self, single_codon_mut_str, template):
        # based on template and the mut_str, construct all the relevant information
        self.template = template
        self.mut_str = single_codon_mut_str

        # dict to store position to the mutated base
        mutpos_to_base = mut_str_to_dic(single_codon_mut_str)

        # check it's indeed a single mutant
        mutpos_codon_list = [int(i) // 3 for i in mutpos_to_base]
        self.mutpos_codon_list = mutpos_codon_list
        assert (
            len(set(mutpos_codon_list)) == 1
        ), "mutation from mut_str found not in the same codon" + str(mut_str)

        self.AA_pos = int(mutpos_codon_list[0])

        self.codon_pos = self.AA_pos * 3

        if self.template == "pare":
            self.wt_codon = WT_PARE_DNA[self.codon_pos : self.codon_pos + 3]
        elif self.template == "pard":
            self.wt_codon = WT_PARD_DNA[self.codon_pos : self.codon_pos + 3]

        self.mut_codon = mutdic_to_mutcodon(mutpos_to_base, self.wt_codon)

        self.wt_aa = translate(self.wt_codon)
        self.mut_aa = translate(self.mut_codon)


class MutantObject:
    """
    Mutant object: each mutant object correpsonds to a mutant read.

    ie.
    could contain multiple mutations across different codons.
    Could contain barcoded wt TGA, wt CCC mutant reads.
    """

    def __init__(
        self, full_mut_str, in_count=None, total_reads=None, od=None, template=None
    ):
        self.template = template
        self.full_mut_str = full_mut_str

        self.muts = {}
        self.total_reads = total_reads
        self.raw_count = in_count
        self.norm_count = float(self.raw_count) / float(self.total_reads) * float(od)

        # deprecated. Use df manipulations of fitness afterwards.
        # to be filled in by a the Timecourse object
        self.fitness = None
        self.fitness_var = None
        self.fitness_od_norm = None
        self.fitness_aa = None
        self.fitness_aa_var = None
        self.fitness_aa_od_norm = None

        # store all the codon strings
        self.codon_muts = {}
        self.__make_codon_muts(full_mut_str, self.template)
        self.num_codon_muts = len(self.codon_muts)

    def __make_codon_muts(self, full_mut_str, template):
        # take single mutant and add to the codon_muts dict

        # make list of codon_mut_str per codon mutation.
        codon_mut_str_list = sep_mut_str_into_codon_mut_str(full_mut_str)
        for single_codon_mut_str in codon_mut_str_list:
            self.codon_muts[single_codon_mut_str] = SingleCodonMutant(
                single_codon_mut_str, template
            )


class SampleObject:
    # total_reads = 'somenumber'
    def __init__(
        self,
        filenames,
        sample_n=None,
        timepoint=None,
        od=None,
        template=None,
        use_nns=False,
        at=None,
        t=None,
    ):
        """
        sample object to store all the mutant reads from a particular experiment.
        filenames   :   list of filepaths which contain classified reads generated by mapClassPe.py
        sample_n    :   name of sample
        at          :   at_label
        """
        self.at_label = at
        self.t_label = t
        self.template = template
        self.sample_n = sample_n
        self.timepoint = int(timepoint)
        self.od = od

        if template == "pard":
            self.wt_seq = WT_PARD_DNA
        elif template == "pare":
            self.wt_seq = WT_PARE_DNA

        # to read all the mutants
        self.mut_count = defaultdict(int)
        self.wt_count = defaultdict(int)
        self.mut_type_count = defaultdict(int)
        self.total_reads = 0
        for f in filenames:
            self.__readMuts(f)

        self.mut_objects = {}
        self.__makeMutObjects()

        # for easy access to single muts specifically, should be referring to the same mut_objects as above
        self.sm_objects = {}
        self.__makeSmObjects()

        print("done init.")


def __readMuts(self, filename):
    """
    takes filepath, generated from mapClassPe, and count the mutants to store in the sample object
    this creates
        -   mut_type_count dic: counts how many reads there are for each particular read classificiation,
            ie. '1_codon': 5,
        -   mut_count: dictionary from mut_str to count
    """
    print("reading muts...")

    with open(filename, "r") as fin:
        csvIn = csv.reader(fin, delimiter="\t")
        for l in csvIn:
            mut_type = l[1]

            # count the number of different classified mutations
            self.mut_type_count[mut_type] += 1

            # deal with the codons mutants
            if mut_type.endswith("_codons"):
                strand = l[2]
                sm = l[5]
                # convert to right pos
                strand, mut_str = correct_mut_str(strand, sm)
                self.mut_count[mut_str] += 1

            # read with wtCCC or wtTGA
            if mut_type == "wtCCC":
                self.wt_count[str(len(self.wt_seq)) + ":CCC"] += 1
            if mut_type == "wtTGA":
                self.wt_count[str(len(self.wt_seq)) + ":TGA"] += 1

            # count the wt dna
            if mut_type.startswith("wt_dna_"):
                self.wt_count["wt"] += 1

    self.total_reads += sum(self.mut_type_count.values())


def __makeMutObjects(self):
    # take all the mut_str from the sample object, and generate a mutant object for each, and store in mut_objects
    for mut_str in self.mut_count:
        self.mut_objects[mut_str] = MutantObject(
            mut_str,
            in_count=self.mut_count[mut_str],
            total_reads=self.total_reads,
            od=self.od,
            template=self.template,
        )


def __makeSmObjects(self):
    # filter the mut_objects for the single codon mutants, and store them in sm_objects.
    for mut_str, mutObj in self.mut_objects.items():
        if mutObj.num_codon_muts == 1:
            self.sm_objects[mut_str] = mutObj


def calc_average_aa_fit(self):
    # calculate average amino acid fitnesses

    for use_od_norm in [True, False]:
        dataPointsDic = {}
        for k, mut_obj in self.sm_objects.items():
            scm_obj = list(mut_obj.codon_muts.values())[0]
            pos = scm_obj.AA_pos
            mc = scm_obj.mut_codon
            if get_fit(mut_obj, use_od_norm):
                if pos not in dataPointsDic.keys():
                    dataPointsDic[pos] = {}
                    dataPointsDic[pos][mc] = float(get_fit(mut_obj, use_od_norm))
                else:
                    dataPointsDic[pos][mc] = float(get_fit(mut_obj, use_od_norm))

        # make amino acid average
        aaAveDataDic = {}
        for pos in dataPointsDic:
            aaAveDataDic[pos] = {}
            mut_codons = dataPointsDic[pos].keys()
            numAAs = Counter([CODON_TABLE[cod] for cod in mut_codons])
            for mut_codon in mut_codons:
                if CODON_TABLE[mut_codon] in aaAveDataDic[pos]:
                    aaAveDataDic[pos][CODON_TABLE[mut_codon]] += dataPointsDic[pos][
                        mut_codon
                    ]
                else:
                    aaAveDataDic[pos][CODON_TABLE[mut_codon]] = dataPointsDic[pos][
                        mut_codon
                    ]
            # divide each amino acid by number of times the codon occured
            for aa in numAAs:
                aaAveDataDic[pos][aa] = aaAveDataDic[pos][aa] / numAAs[aa]

        # store the average in the sm_objects
        for k, mut_obj in self.sm_objects.items():
            scm_obj = list(mut_obj.codon_muts.values())[0]
            pos = scm_obj.AA_pos
            mut_aa = scm_obj.mut_aa
            if pos in aaAveDataDic and mut_aa in aaAveDataDic[pos]:
                if use_od_norm:
                    mut_obj.fitness_aa_od_norm = aaAveDataDic[pos][mut_aa]
                else:
                    mut_obj.fitness_aa = aaAveDataDic[pos][mut_aa]
    return


class Timecourse:
    def __init__(self, template, s_obj_list=None, s_fin_list=None, t=None, at=None):
        """
        s_obj_list      :   sample_object list sorted by timepoint.
        s_fin_list      :   list of tuples with (finpath, time) samples files in right order of timecourse
        """
        self.template = template
        self.at_label = at
        self.t_label = t

        # store samples according to files
        if s_obj_list == None:
            self.samples = []  # ordered list of samples
            for s in s_fin_list:
                print("reading in ", s[0])
                self.samples.append(SampleObject(s[0], s[1]))
        else:
            self.samples = s_obj_list

        self.num_samples = len(self.samples)
        self.raw_read_threshold = 0

        if template == "pare":
            self.primary_seq_length = len(WT_PARE_DNA)
        elif template == "pard":
            self.primary_seq_length = len(WT_PARD_DNA)

    def calculateFitness(
        self, first_timepoint=60, fit_wrt_sample_stop=False, fit_wrt_vals=None
    ):
        # wrt_stop is if I want to calculate the fitness wrt to the stop codons, instead of the wt codon.
        # if supply wrt_stop as True: normalize fitness to the stop codons within sample
        # if supply stop_counts_to_normalize_to tuple

        print("calculating fitness...")

        for s in self.samples:
            if "wt" not in s.wt_count:
                print(
                    "sample does not have any wt reads, careful interpret fitness values"
                )

        # check that mutant has a read number above threshold in the first sample,
        # but allow inaccurate fitness calculation with low read counts at end
        first_sample = next(
            (s for s in self.samples if s.timepoint == first_timepoint), None
        )
        print(first_sample.timepoint)

        # make the keys that are found in all samples
        # if there is a raw read threshold set:
        if self.raw_read_threshold != 0:
            mutKeys_thresh = []
            for s in self.samples:
                mutKeys_thresh.append(
                    set(
                        [
                            k
                            for k, v in s.mut_objects.iteritems()
                            if v.raw_count > self.raw_read_threshold
                        ]
                    )
                )

            self.intersect_muts_threshold = set(first_sample.mut_objects.keys())
            for ks in mutKeys_thresh:
                self.intersect_muts_threshold = ks.intersection(
                    self.intersect_muts_threshold
                )

        else:
            # check that it exists as key in the first sample but it can be outcompeted at a later timepoint (at
            # least 5 reads in the first sample)
            self.intersect_muts_threshold = set(
                [
                    k
                    for k in first_sample.mut_objects.keys()
                    if first_sample.mut_objects[k].raw_count > 5
                ]
            )
            print("calculating fitness for %i", len(self.intersect_muts_threshold))

        # calculate fitness and store for each sample
        for i in range(len(self.samples)):
            s = self.samples[i]
            # do not calculate fitness for first-timepoint
            if s.timepoint != first_timepoint:
                # moved this out of the mut for loop so it's only computed once.
                if fit_wrt_sample_stop == True:
                    stop_freq_start = get_total_read_count(
                        get_stop_obj_list(first_sample)
                    )
                    stop_freq_end = get_total_read_count(get_stop_obj_list(s))

                for mut in self.intersect_muts_threshold:
                    # get variables needed for calulating relGR

                    time_diff = int(s.timepoint) - int(first_sample.timepoint)
                    wt_freq_start = first_sample.wt_count["wt"] + 0.5
                    wt_freq_end = s.wt_count["wt"] + 0.5
                    mut_freq_start = first_sample.mut_objects[mut].raw_count + 0.5

                    if mut in s.mut_objects.keys():
                        mut_freq_end = s.mut_objects[mut].raw_count + 0.5
                    else:
                        mut_freq_end = 0.5

                    total_reads_start = first_sample.total_reads
                    total_od_start = first_sample.od

                    total_reads_end = s.total_reads
                    total_od_end = s.od

                    rel_GR = (
                        (
                            float(
                                np.log(mut_freq_end)
                                - np.log(wt_freq_end)
                                - np.log(mut_freq_start)
                                + np.log(wt_freq_start)
                            )
                        )
                    ) / time_diff

                    rel_GR_od_norm = (
                        np.log(mut_freq_end)
                        + np.log(float(total_od_end))
                        - np.log(total_reads_end)
                        - (
                            np.log(mut_freq_start)
                            + np.log(float(total_od_start))
                            - np.log(total_reads_start)
                        )
                        - (
                            np.log(wt_freq_end)
                            + np.log(float(total_od_end))
                            - np.log(total_reads_end)
                            - (
                                np.log(wt_freq_start)
                                + np.log(float(total_od_start))
                                - np.log(total_reads_start)
                            )
                        )
                    ) / time_diff

                    # if you want the relative growth rate wrt to the stop codons within that sample
                    if fit_wrt_sample_stop == True:
                        rel_GR = (
                            (
                                float(
                                    np.log(mut_freq_end)
                                    - np.log(stop_freq_end)
                                    - np.log(mut_freq_start)
                                    + np.log(stop_freq_start)
                                )
                            )
                        ) / time_diff

                    # if you want to measure rel growth rate wrt to stop codon counts in all the samples
                    if fit_wrt_vals != None:
                        if len(fit_wrt_vals) != len(self.samples):
                            print(
                                "dimensions of samples and supplied counts\
                              mismatch",
                                len(fit_wrt_vals),
                                len(self.samples),
                            )
                            break
                        stop_freq_start = fit_wrt_vals[0]
                        stop_freq_end = fit_wrt_vals[1]
                        rel_GR = (
                            (
                                float(
                                    np.log(mut_freq_end)
                                    - np.log(stop_freq_end)
                                    - np.log(mut_freq_start)
                                    + np.log(stop_freq_start)
                                )
                            )
                        ) / time_diff

                    if mut in s.mut_objects:
                        s.mut_objects[mut].fitness = rel_GR
                        s.mut_objects[mut].fitness_od_norm = rel_GR_od_norm
                    else:
                        # make this object and update
                        s.mut_objects[mut] = deepcopy(first_sample.mut_objects[mut])
                        s.mut_objects[mut].raw_count = 0.5
                        s.mut_objects[mut].total_reads = s.total_reads
                        s.mut_objects[mut].norm_count = (
                            0.5 / s.total_reads * float(s.od)
                        )
                        s.mut_objects[mut].fitness = rel_GR
                        s.mut_objects[mut].fitness_od_norm = rel_GR_od_norm
